What's wrong with this query?


The initial query is functionally correct; it will compile and even work in a small set, but as soon as your data grows, it will let you down.

Using the YEAR() function in the WHERE clause can have two significant drawbacks:

ğŸ­. ğ—£ğ—²ğ—¿ğ—³ğ—¼ğ—¿ğ—ºğ—®ğ—»ğ—°ğ—² ğ—œğ—ºğ—½ğ—®ğ—°ğ˜ ğ——ğ˜‚ğ—² ğ˜ğ—¼ ğ—™ğ˜‚ğ—¹ğ—¹ ğ—§ğ—®ğ—¯ğ—¹ğ—² ğ—¦ğ—°ğ—®ğ—»

When the YEAR() function is applied to s.SaleDate, SQL needs to evaluate this function for every row in the table.
 
This often results in a full table scan, where every row is checked against the condition. That will hurt, especially for tables with millions of rows.

ğŸ®. ğ—œğ—»ğ—²ğ—³ğ—³ğ—²ğ—°ğ˜ğ—¶ğ˜ƒğ—² ğ—œğ—»ğ—±ğ—²ğ˜… ğ—¨ğ˜€ğ—²

The function YEAR(s.SaleDate) prevents the query optimizer from using any indexes on the SaleDate column.
 
Indexes help the database quickly locate and filter the relevant rows, but they cannot be used when the column is wrapped inside a function.
 
As a result, the query's performance suffers because the database is unable to take advantage of the available indexing.

ğ—” ğ—•ğ—²ğ˜ğ˜ğ—²ğ—¿ ğ—”ğ—½ğ—½ğ—¿ğ—¼ğ—®ğ—°ğ—µ

Use a range-based query that allows the database to utilize indexes effectively. 

The BETWEEN clause filters records by defining a range of dates (2024-01-01 to 2024-12-31).

The query optimizer will use any index on the SaleDate column to locate the relevant rows without scanning the entire table.
